//===- subzero/src/IceInstX8632.def - X-macros for x86-32 insts -*- C++ -*-===//
//
//                        The Subzero Code Generator
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines properties of lowered x86-32 instructions in the
// form of x-macros.
//
//===----------------------------------------------------------------------===//

#ifndef SUBZERO_SRC_ICEINSTX8632_DEF
#define SUBZERO_SRC_ICEINSTX8632_DEF

// NOTE: esp is not considered isInt, to avoid register allocating it.
#define REGX8632_GPR_TABLE                                              \
  /* val, encode, name, name16, name8, scratch, preserved, stackptr,    \
     frameptr, isI8, isInt, isFP */                                     \
  X(Reg_eax, 0, "eax", "ax", "al", 1, 0, 0, 0, 1, 1, 0)                 \
  X(Reg_ecx, 1, "ecx", "cx", "cl", 1, 0, 0, 0, 1, 1, 0)                 \
  X(Reg_edx, 2, "edx", "dx", "dl", 1, 0, 0, 0, 1, 1, 0)                 \
  X(Reg_ebx, 3, "ebx", "bx", "bl", 0, 1, 0, 0, 1, 1, 0)                 \
  X(Reg_esp, 4, "esp", "sp", ""  , 0, 0, 1, 0, 0, 0, 0)                 \
  X(Reg_ebp, 5, "ebp", "bp", ""  , 0, 1, 0, 1, 0, 1, 0)                 \
  X(Reg_esi, 6, "esi", "si", ""  , 0, 1, 0, 0, 0, 1, 0)                 \
  X(Reg_edi, 7, "edi", "di", ""  , 0, 1, 0, 0, 0, 1, 0)      

#define REGX8632_XMM_TABLE                                              \
  X(Reg_xmm0, 0, "xmm0", "" , "" , 1, 0, 0, 0, 0, 0, 1)                 \
  X(Reg_xmm1, 1, "xmm1", "" , "" , 1, 0, 0, 0, 0, 0, 1)                 \
  X(Reg_xmm2, 2, "xmm2", "" , "" , 1, 0, 0, 0, 0, 0, 1)                 \
  X(Reg_xmm3, 3, "xmm3", "" , "" , 1, 0, 0, 0, 0, 0, 1)                 \
  X(Reg_xmm4, 4, "xmm4", "" , "" , 1, 0, 0, 0, 0, 0, 1)                 \
  X(Reg_xmm5, 5, "xmm5", "" , "" , 1, 0, 0, 0, 0, 0, 1)                 \
  X(Reg_xmm6, 6, "xmm6", "" , "" , 1, 0, 0, 0, 0, 0, 1)                 \
  X(Reg_xmm7, 7, "xmm7", "" , "" , 1, 0, 0, 0, 0, 0, 1)                 \
//#define X(val, encode, name, name16, name8, scratch, preserved, stackptr,
//          frameptr, isI8, isInt, isFP)

// We also provide a combined table, so that there is a namespace where
// all of the registers are considered and have distinct numberings.
// This is in contrast to the above, where the "encode" is based on how
// the register numbers will be encoded in binaries and values can overlap.
// Note that the isI8 attributed of Reg_ah is not set.  In general we
// don't want the register allocator choosing Reg_ah, in particular
// for lowering insertelement to pinsrb where internally we use an
// 8-bit operand but externally pinsrb uses a 32-bit register, in
// which Reg_ah doesn't map to eax.
#define REGX8632_TABLE                                                  \
  /* val, encode, name, name16, name8, scratch, preserved, stackptr,    \
     frameptr, isI8, isInt, isFP */                                     \
  REGX8632_GPR_TABLE                                                    \
  X(Reg_ah, 4, "???", "" , "ah", 0, 0, 0, 0, 0, 0, 0)                   \
  REGX8632_XMM_TABLE
//#define X(val, encode, name, name16, name8, scratch, preserved, stackptr,
//          frameptr, isI8, isInt, isFP)

#define REGX8632_TABLE_BOUNDS                                           \
  /* val, init */                                                       \
  X(Reg_GPR_First, = Reg_eax)                                           \
  X(Reg_GPR_Last,  = Reg_edi)                                           \
  X(Reg_XMM_First, = Reg_xmm0)                                          \
  X(Reg_XMM_Last,  = Reg_xmm7)                                          \
//define X(val, init)

// We also need the encodings for the Byte registers (other info overlaps
// what is in the REGX8632_GPR_TABLE).
#define REGX8632_BYTEREG_TABLE                                          \
  /* val, encode */                                                     \
  X(Reg_al, = 0) \
  X(Reg_cl, = 1) \
  X(Reg_dl, = 2) \
  X(Reg_bl, = 3) \
  X(Reg_ah, = 4)
//#define X(val, encode)

// X86 segment registers.
#define SEG_REGX8632_TABLE         \
  /* enum value, name, prefix */   \
  X(SegReg_CS, "cs", 0x2E)         \
  X(SegReg_DS, "ds", 0x3E)         \
  X(SegReg_ES, "es", 0x26)         \
  X(SegReg_SS, "ss", 0x36)         \
  X(SegReg_FS, "fs", 0x64)         \
  X(SegReg_GS, "gs", 0x65)         \
//#define X(val, name, prefix)

// X87 ST(n) registers.
#define X87ST_REGX8632_TABLE         \
  /* enum value, encode, name */     \
  X(X87ST_First, = 0, "st(0)")       \
  X(X87ST_0, = 0, "st(0)")           \
  X(X87ST_1, = 1, "st(1)")           \
  X(X87ST_2, = 2, "st(2)")           \
  X(X87ST_3, = 3, "st(3)")           \
  X(X87ST_4, = 4, "st(4)")           \
  X(X87ST_5, = 5, "st(5)")           \
  X(X87ST_6, = 6, "st(6)")           \
  X(X87ST_7, = 7, "st(7)")           \
  X(X87ST_Last, = 7, "st(7)")        \
//#define X(val, encode, name)

#define ICEINSTX8632BR_TABLE   \
  /* enum value, encode, opposite, dump, emit */ \
  X(Br_o,  = 0,       Br_no,    "o",  "jo")                \
  X(Br_no, = 1,       Br_o,     "no", "jno")               \
  X(Br_b,  = 2,       Br_ae,    "b",  "jb")                \
  X(Br_ae, = 3,       Br_b,     "ae", "jae")               \
  X(Br_e,  = 4,       Br_ne,    "e",  "je")                \
  X(Br_ne, = 5,       Br_e,     "ne", "jne")               \
  X(Br_be, = 6,       Br_a,     "be", "jbe")               \
  X(Br_a,  = 7,       Br_be,    "a",  "ja")                \
  X(Br_s,  = 8,       Br_ns,    "s",  "js")                \
  X(Br_ns, = 9,       Br_s,     "ns", "jns")               \
  X(Br_p,  = 10,      Br_np,    "p",  "jp")                \
  X(Br_np, = 11,      Br_p,     "np", "jnp")               \
  X(Br_l,  = 12,      Br_ge,    "l",  "jl")                \
  X(Br_ge, = 13,      Br_l,     "ge", "jge")               \
  X(Br_le, = 14,      Br_g,     "le", "jle")               \
  X(Br_g,  = 15,      Br_le,    "g",  "jg")                \
//#define X(tag, encode, opp, dump, emit)

#define ICEINSTX8632CMPPS_TABLE \
  /* enum value, emit */        \
  X(Cmpps_eq,    "eq")          \
  X(Cmpps_lt,    "lt")          \
  X(Cmpps_le,    "le")          \
  X(Cmpps_unord, "unord")       \
  X(Cmpps_neq,   "neq")         \
  X(Cmpps_nlt,   "nlt")         \
  X(Cmpps_nle,   "nle")         \
  X(Cmpps_ord,   "ord")         \
//#define X(tag, emit)

#define ICETYPEX8632_TABLE                                       \
  /* tag,          element type, cvt, sdss,  pack, width, fld */ \
  X(IceType_void,  IceType_void, "?" , ""  , "" ,  "",  "")      \
  X(IceType_i1,    IceType_void, "si", ""  , "" ,  "b", "")      \
  X(IceType_i8,    IceType_void, "si", ""  , "" ,  "b", "")      \
  X(IceType_i16,   IceType_void, "si", ""  , "" ,  "w", "")      \
  X(IceType_i32,   IceType_void, "si", ""  , "" ,  "l", "")      \
  X(IceType_i64,   IceType_void, "si", ""  , "" ,  "q", "")      \
  X(IceType_f32,   IceType_void, "ss", "ss", "d",  "",  "s")     \
  X(IceType_f64,   IceType_void, "sd", "sd", "q",  "",  "l")     \
  X(IceType_v4i1,  IceType_i32 , "?" , ""  , "d",  "",  "")      \
  X(IceType_v8i1,  IceType_i16 , "?" , ""  , "w",  "",  "")      \
  X(IceType_v16i1, IceType_i8  , "?" , ""  , "b",  "",  "")      \
  X(IceType_v16i8, IceType_i8  , "?" , ""  , "b",  "",  "")      \
  X(IceType_v8i16, IceType_i16 , "?" , ""  , "w",  "",  "")      \
  X(IceType_v4i32, IceType_i32 , "dq", ""  , "d",  "",  "")      \
  X(IceType_v4f32, IceType_f32 , "ps", ""  , "d",  "",  "")      \
//#define X(tag, elementty, cvt, sdss, pack, width, fld)

#endif // SUBZERO_SRC_ICEINSTX8632_DEF
