//===- subzero/src/IceInstARM32.def - X-Macros for ARM32 insts --*- C++ -*-===//
//
//                        The Subzero Code Generator
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines properties of ARM32 instructions in the form of x-macros.
//
//===----------------------------------------------------------------------===//

#ifndef SUBZERO_SRC_ICEINSTARM32_DEF
#define SUBZERO_SRC_ICEINSTARM32_DEF

// NOTE: PC and SP are not considered isInt, to avoid register allocating.
//
// For the NaCl sandbox we also need to r9 for TLS, so just reserve always.
// TODO(jvoung): Allow r9 to be isInt when sandboxing is turned off
// (native mode).
//
// IP is not considered isInt to reserve it as a scratch register. A scratch
// register is useful for expanding instructions post-register allocation.
//
// LR is not considered isInt to avoid being allocated as a register.
// It is technically preserved, but save/restore is handled separately,
// based on whether or not the function MaybeLeafFunc.

// ALIASESn is a family of macros that we use to define register aliasing in
// ARM32. n indicates how many aliases are being provided to the macro. It
// assumes the parameters are register names declared in a namespace/class named
// RegARM32.
#define ALIASES1(r0)                                                           \
    {RegARM32::r0}
#define ALIASES2(r0, r1)                                                       \
    {RegARM32::r0, RegARM32::r1}
#define ALIASES3(r0, r1, r2)                                                   \
    {RegARM32::r0, RegARM32::r1, RegARM32::r2}
#define ALIASES4(r0, r1, r2, r3)                                               \
    {RegARM32::r0, RegARM32::r1, RegARM32::r2, RegARM32::r3}
#define ALIASES7(r0, r1, r2, r3, r4, r5, r6)                                   \
    {RegARM32::r0, RegARM32::r1, RegARM32::r2, RegARM32::r3, RegARM32::r4,     \
     RegARM32::r5,RegARM32::r6}


#define REGARM32_GPR_TABLE                                                     \
  /* val, encode, name, scratch, preserved, stackptr, frameptr,                \
     isInt, isFP32, isFP64, isVec128, aliases_init */                          \
  X(Reg_r0,  0, "r0",   1, 0, 0, 0, 1, 0, 0, 0, ALIASES1(Reg_r0))              \
  X(Reg_r1,  1, "r1",   1, 0, 0, 0, 1, 0, 0, 0, ALIASES1(Reg_r1))              \
  X(Reg_r2,  2, "r2",   1, 0, 0, 0, 1, 0, 0, 0, ALIASES1(Reg_r2))              \
  X(Reg_r3,  3, "r3",   1, 0, 0, 0, 1, 0, 0, 0, ALIASES1(Reg_r3))              \
  X(Reg_r4,  4, "r4",   0, 1, 0, 0, 1, 0, 0, 0, ALIASES1(Reg_r4))              \
  X(Reg_r5,  5, "r5",   0, 1, 0, 0, 1, 0, 0, 0, ALIASES1(Reg_r5))              \
  X(Reg_r6,  6, "r6",   0, 1, 0, 0, 1, 0, 0, 0, ALIASES1(Reg_r6))              \
  X(Reg_r7,  7, "r7",   0, 1, 0, 0, 1, 0, 0, 0, ALIASES1(Reg_r7))              \
  X(Reg_r8,  8, "r8",   0, 1, 0, 0, 1, 0, 0, 0, ALIASES1(Reg_r8))              \
  X(Reg_r9,  9, "r9",   0, 1, 0, 0, 0, 0, 0, 0, ALIASES1(Reg_r9))              \
  X(Reg_r10, 10, "r10", 0, 1, 0, 0, 1, 0, 0, 0, ALIASES1(Reg_r10))             \
  X(Reg_fp,  11, "fp",  0, 1, 0, 1, 1, 0, 0, 0, ALIASES1(Reg_fp))              \
  X(Reg_ip,  12, "ip",  1, 0, 0, 0, 0, 0, 0, 0, ALIASES1(Reg_ip))              \
  X(Reg_sp,  13, "sp",  0, 0, 1, 0, 0, 0, 0, 0, ALIASES1(Reg_sp))              \
  X(Reg_lr,  14, "lr",  0, 0, 0, 0, 0, 0, 0, 0, ALIASES1(Reg_lr))              \
  X(Reg_pc,  15, "pc",  0, 0, 0, 0, 0, 0, 0, 0, ALIASES1(Reg_pc))
//#define X(val, encode, name, scratch, preserved, stackptr, frameptr,
//          isInt, isFP32, isFP64, isVec128, aliases_init)

// S registers 0-15 are scratch, but 16-31 are preserved.
// Regenerate this with the following python script:
//
// def print_sregs():
//   for i in xrange(0, 32):
//     is_scratch = 1 if i < 16 else 0
//     is_preserved = 1 if i >= 16 else 0
//     print ('  X(Reg_s{regnum:<2}, {regnum:<2}, "s{regnum}", ' +
//            '{scratch}, {preserved}, 0, 0, 0, 1, 0, 0, ' +
//            'ALIASES(Reg_s{regnum_s:<2}, Reg_d{regnum:<2}, ' + 
//            'Reg_q{regnum_q:<2}))    \\').format(
//            regnum=i, regnum_d=i>>1,
//            regnum_q=i>>2, scratch=is_scratch, preserved=is_preserved)
//
// print_sregs()
//
#define REGARM32_FP32_TABLE                                                    \
  /* val, encode, name, scratch, preserved, stackptr, frameptr,                \
     isInt, isFP32, isFP64, isVec128, aliases_init */                          \
  X(Reg_s0 , 0 , "s0" , 1, 0, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s0 , Reg_d0 , Reg_q0))                                        \
  X(Reg_s1 , 1 , "s1" , 1, 0, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s1 , Reg_d0 , Reg_q0))                                        \
  X(Reg_s2 , 2 , "s2" , 1, 0, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s2 , Reg_d1 , Reg_q0))                                        \
  X(Reg_s3 , 3 , "s3" , 1, 0, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s3 , Reg_d1 , Reg_q0))                                        \
  X(Reg_s4 , 4 , "s4" , 1, 0, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s4 , Reg_d2 , Reg_q1))                                        \
  X(Reg_s5 , 5 , "s5" , 1, 0, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s5 , Reg_d2 , Reg_q1))                                        \
  X(Reg_s6 , 6 , "s6" , 1, 0, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s6 , Reg_d3 , Reg_q1))                                        \
  X(Reg_s7 , 7 , "s7" , 1, 0, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s7 , Reg_d3 , Reg_q1))                                        \
  X(Reg_s8 , 8 , "s8" , 1, 0, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s8 , Reg_d4 , Reg_q2))                                        \
  X(Reg_s9 , 9 , "s9" , 1, 0, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s9 , Reg_d4 , Reg_q2))                                        \
  X(Reg_s10, 10, "s10", 1, 0, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s10, Reg_d5 , Reg_q2))                                        \
  X(Reg_s11, 11, "s11", 1, 0, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s11, Reg_d5 , Reg_q2))                                        \
  X(Reg_s12, 12, "s12", 1, 0, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s12, Reg_d6 , Reg_q3))                                        \
  X(Reg_s13, 13, "s13", 1, 0, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s13, Reg_d6 , Reg_q3))                                        \
  X(Reg_s14, 14, "s14", 1, 0, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s14, Reg_d7 , Reg_q3))                                        \
  X(Reg_s15, 15, "s15", 1, 0, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s15, Reg_d7 , Reg_q3))                                        \
  X(Reg_s16, 16, "s16", 0, 1, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s16, Reg_d8 , Reg_q4))                                        \
  X(Reg_s17, 17, "s17", 0, 1, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s17, Reg_d8 , Reg_q4))                                        \
  X(Reg_s18, 18, "s18", 0, 1, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s18, Reg_d9 , Reg_q4))                                        \
  X(Reg_s19, 19, "s19", 0, 1, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s19, Reg_d9 , Reg_q4))                                        \
  X(Reg_s20, 20, "s20", 0, 1, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s20, Reg_d10, Reg_q5))                                        \
  X(Reg_s21, 21, "s21", 0, 1, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s21, Reg_d10, Reg_q5))                                        \
  X(Reg_s22, 22, "s22", 0, 1, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s22, Reg_d11, Reg_q5))                                        \
  X(Reg_s23, 23, "s23", 0, 1, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s23, Reg_d11, Reg_q5))                                        \
  X(Reg_s24, 24, "s24", 0, 1, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s24, Reg_d12, Reg_q6))                                        \
  X(Reg_s25, 25, "s25", 0, 1, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s25, Reg_d12, Reg_q6))                                        \
  X(Reg_s26, 26, "s26", 0, 1, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s26, Reg_d13, Reg_q6))                                        \
  X(Reg_s27, 27, "s27", 0, 1, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s27, Reg_d13, Reg_q6))                                        \
  X(Reg_s28, 28, "s28", 0, 1, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s28, Reg_d14, Reg_q7))                                        \
  X(Reg_s29, 29, "s29", 0, 1, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s29, Reg_d14, Reg_q7))                                        \
  X(Reg_s30, 30, "s30", 0, 1, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s30, Reg_d15, Reg_q7))                                        \
  X(Reg_s31, 31, "s31", 0, 1, 0, 0, 0, 1, 0, 0,                                \
    ALIASES3(Reg_s31, Reg_d15, Reg_q7)) 
//#define X(val, encode, name, scratch, preserved, stackptr, frameptr,
//          isInt, isFP32,isFP64, isVec128, aliases_init)

// D registers 0-7 are scratch, 8-15 are preserved, and 16-31
// are also scratch (if supported by the D32 feature vs D16).
// D registers are defined in reverse order so that, during register allocation,
// Subzero will prefer higher D registers. In processors supporting the D32
// feature this will effectively cause double allocation to bias towards
// allocating "high" D registers, which do not alias any S registers.
//
// Regenerate this with the following python script:
// def print_dregs():
//   for i in xrange(31, 15, -1):
//     is_scratch = 1 if (i < 8 or i >= 16) else 0
//     is_preserved = 1 if (8 <= i and i < 16) else 0
//     print ('  X(Reg_d{regnum:<2}, {regnum:<2}, "d{regnum}", ' +
//            '{scratch}, {preserved}, 0, 0, 0, 0, 1, 0, ' +
//            'ALIASES(Reg_d{regnum:<2}, Reg_q{regnum_q:<2})    \\').format(
//            regnum=i, regnum_q=i>>1, scratch=is_scratch,
//            preserved=is_preserved)
//   for i in xrange(15, -1, -1):
//     is_scratch = 1 if (i < 8 or i >= 16) else 0
//     is_preserved = 1 if (8 <= i and i < 16) else 0
//     print ('  X(Reg_d{regnum:<2}, {regnum:<2}, "d{regnum}", ' +
//            '{scratch}, {preserved}, 0, 0, 0, 0, 1, 0, ' +
//            'ALIASES(Reg_s{regnum_s0:<2}, Reg_s{regnum_s1:<2}, ' +
//            'Reg_d{regnum:<2}, Reg_q{regnum_q:<2}))   \\').format(
//            regnum_s0 = (i<<1), regnum_s1 = (i<<1) + 1, regnum=i,
//            regnum_q=i>>1, scratch=is_scratch, preserved=is_preserved)
//
// print_dregs()
//
#define REGARM32_FP64_TABLE                                                    \
  /* val, encode, name, scratch, preserved, stackptr, frameptr,                \
     isInt, isFP32, isFP64, isVec128, aliases_init */                          \
  X(Reg_d31, 31, "d31", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES2(Reg_d31, Reg_q15))                                                \
  X(Reg_d30, 30, "d30", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES2(Reg_d30, Reg_q15))                                                \
  X(Reg_d29, 29, "d29", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES2(Reg_d29, Reg_q14))                                                \
  X(Reg_d28, 28, "d28", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES2(Reg_d28, Reg_q14))                                                \
  X(Reg_d27, 27, "d27", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES2(Reg_d27, Reg_q13))                                                \
  X(Reg_d26, 26, "d26", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES2(Reg_d26, Reg_q13))                                                \
  X(Reg_d25, 25, "d25", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES2(Reg_d25, Reg_q12))                                                \
  X(Reg_d24, 24, "d24", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES2(Reg_d24, Reg_q12))                                                \
  X(Reg_d23, 23, "d23", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES2(Reg_d23, Reg_q11))                                                \
  X(Reg_d22, 22, "d22", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES2(Reg_d22, Reg_q11))                                                \
  X(Reg_d21, 21, "d21", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES2(Reg_d21, Reg_q10))                                                \
  X(Reg_d20, 20, "d20", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES2(Reg_d20, Reg_q10))                                                \
  X(Reg_d19, 19, "d19", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES2(Reg_d19, Reg_q9))                                                 \
  X(Reg_d18, 18, "d18", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES2(Reg_d18, Reg_q9))                                                 \
  X(Reg_d17, 17, "d17", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES2(Reg_d17, Reg_q8))                                                 \
  X(Reg_d16, 16, "d16", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES2(Reg_d16, Reg_q8))                                                 \
  X(Reg_d15, 15, "d15", 0, 1, 0, 0, 0, 0, 1, 0,                                \
    ALIASES4(Reg_s30, Reg_s31, Reg_d15, Reg_q7))                               \
  X(Reg_d14, 14, "d14", 0, 1, 0, 0, 0, 0, 1, 0,                                \
    ALIASES4(Reg_s28, Reg_s29, Reg_d14, Reg_q7))                               \
  X(Reg_d13, 13, "d13", 0, 1, 0, 0, 0, 0, 1, 0,                                \
    ALIASES4(Reg_s26, Reg_s27, Reg_d13, Reg_q6))                               \
  X(Reg_d12, 12, "d12", 0, 1, 0, 0, 0, 0, 1, 0,                                \
    ALIASES4(Reg_s24, Reg_s25, Reg_d12, Reg_q6))                               \
  X(Reg_d11, 11, "d11", 0, 1, 0, 0, 0, 0, 1, 0,                                \
    ALIASES4(Reg_s22, Reg_s23, Reg_d11, Reg_q5))                               \
  X(Reg_d10, 10, "d10", 0, 1, 0, 0, 0, 0, 1, 0,                                \
    ALIASES4(Reg_s20, Reg_s21, Reg_d10, Reg_q5))                               \
  X(Reg_d9 , 9 ,  "d9", 0, 1, 0, 0, 0, 0, 1, 0,                                \
    ALIASES4(Reg_s18, Reg_s19, Reg_d9 , Reg_q4))                               \
  X(Reg_d8 , 8 ,  "d8", 0, 1, 0, 0, 0, 0, 1, 0,                                \
    ALIASES4(Reg_s16, Reg_s17, Reg_d8 , Reg_q4))                               \
  X(Reg_d7 , 7 ,  "d7", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES4(Reg_s14, Reg_s15, Reg_d7 , Reg_q3))                               \
  X(Reg_d6 , 6 ,  "d6", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES4(Reg_s12, Reg_s13, Reg_d6 , Reg_q3))                               \
  X(Reg_d5 , 5 ,  "d5", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES4(Reg_s10, Reg_s11, Reg_d5 , Reg_q2))                               \
  X(Reg_d4 , 4 ,  "d4", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES4(Reg_s8 , Reg_s9 , Reg_d4 , Reg_q2))                               \
  X(Reg_d3 , 3 ,  "d3", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES4(Reg_s6 , Reg_s7 , Reg_d3 , Reg_q1))                               \
  X(Reg_d2 , 2 ,  "d2", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES4(Reg_s4 , Reg_s5 , Reg_d2 , Reg_q1))                               \
  X(Reg_d1 , 1 ,  "d1", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES4(Reg_s2 , Reg_s3 , Reg_d1 , Reg_q0))                               \
  X(Reg_d0 , 0 ,  "d0", 1, 0, 0, 0, 0, 0, 1, 0,                                \
    ALIASES4(Reg_s0 , Reg_s1 , Reg_d0 , Reg_q0)) 
//#define X(val, encode, name, scratch, preserved, stackptr, frameptr,
//          isInt, isFP32, isFP64, isVec128, aliases_init)

// Q registers 0-3 are scratch, 4-7 are preserved, and 8-15
// are also scratch (if supported by the D32 feature).
// Q registers are defined in reverse order for the same reason as D registers.
//
// Regenerate this with the following python script:
// def print_qregs():
//   for i in xrange(15, 7, -1):
//     is_scratch = 1 if (i < 4 or i >= 8) else 0
//     is_preserved = 1 if (4 <= i and i < 8) else 0
//     print ('  X(Reg_q{regnum:<2}, {regnum:<2}, "q{regnum}", ' +
//            '{scratch}, {preserved}, 0, 0, 0, 0, 0, 1, ALIASES(' +
//            'Reg_d{regnum_d0:<2}, Reg_d{regnum_d1:<2}, ' +
//            'Reg_q{regnum:<2}))    \\').format(
//            regnum_d0=(i<<1), regnum_d1=(i<<1)+1, regnum=i,
//            scratch=is_scratch, preserved=is_preserved)
//   for i in xrange(7, -1, -1):
//     is_scratch = 1 if (i < 4 or i >= 8) else 0
//     is_preserved = 1 if (4 <= i and i < 8) else 0
//     print ('  X(Reg_q{regnum:<2}, {regnum:<2}, "q{regnum}", ' +
//            '{scratch}, {preserved}, 0, 0, 0, 0, 0, 1, ALIASES(' +
//            'Reg_s{regnum_s0:<2}, Reg_s{regnum_s1:<2}, ' +
//            'Reg_s{regnum_s2:<2}, Reg_s{regnum_s3:<2}, ' +
//            'Reg_d{regnum_d0:<2}, Reg_d{regnum_d1:<2}, ' +
//            'Reg_q{regnum:<2}))    \\').format(
//            regnum_s0=(i<<2), regnum_s1=(i<<2)+1, regnum_s2=(i<<2)+2,
//            regnum_s3=(i<<2)+3, regnum_d0=(i<<1), regnum_d1=(i<<1)+1,
//            regnum=i, scratch=is_scratch, preserved=is_preserved)
//
// print_qregs()
//
#define REGARM32_VEC128_TABLE                                                  \
  /* val, encode, name, scratch, preserved, stackptr, frameptr,                \
     isInt, isFP32, isFP64, isVec128, alias_init */                            \
  X(Reg_q15, 15, "q15", 1, 0, 0, 0, 0, 0, 0, 1,                                \
    ALIASES3(Reg_d30, Reg_d31, Reg_q15))                                       \
  X(Reg_q14, 14, "q14", 1, 0, 0, 0, 0, 0, 0, 1,                                \
    ALIASES3(Reg_d28, Reg_d29, Reg_q14))                                       \
  X(Reg_q13, 13, "q13", 1, 0, 0, 0, 0, 0, 0, 1,                                \
    ALIASES3(Reg_d26, Reg_d27, Reg_q13))                                       \
  X(Reg_q12, 12, "q12", 1, 0, 0, 0, 0, 0, 0, 1,                                \
    ALIASES3(Reg_d24, Reg_d25, Reg_q12))                                       \
  X(Reg_q11, 11, "q11", 1, 0, 0, 0, 0, 0, 0, 1,                                \
    ALIASES3(Reg_d22, Reg_d23, Reg_q11))                                       \
  X(Reg_q10, 10, "q10", 1, 0, 0, 0, 0, 0, 0, 1,                                \
    ALIASES3(Reg_d20, Reg_d21, Reg_q10))                                       \
  X(Reg_q9 , 9 , "q9", 1, 0, 0, 0, 0, 0, 0, 1,                                 \
    ALIASES3(Reg_d18, Reg_d19, Reg_q9))                                        \
  X(Reg_q8 , 8 , "q8", 1, 0, 0, 0, 0, 0, 0, 1,                                 \
    ALIASES3(Reg_d16, Reg_d17, Reg_q8))                                        \
  X(Reg_q7 , 7 , "q7", 0, 1, 0, 0, 0, 0, 0, 1,                                 \
    ALIASES7(Reg_s28, Reg_s29, Reg_s30, Reg_s31, Reg_d14, Reg_d15, Reg_q7))    \
  X(Reg_q6 , 6 , "q6", 0, 1, 0, 0, 0, 0, 0, 1,                                 \
    ALIASES7(Reg_s24, Reg_s25, Reg_s26, Reg_s27, Reg_d12, Reg_d13, Reg_q6))    \
  X(Reg_q5 , 5 , "q5", 0, 1, 0, 0, 0, 0, 0, 1,                                 \
    ALIASES7(Reg_s20, Reg_s21, Reg_s22, Reg_s23, Reg_d10, Reg_d11, Reg_q5))    \
  X(Reg_q4 , 4 , "q4", 0, 1, 0, 0, 0, 0, 0, 1,                                 \
    ALIASES7(Reg_s16, Reg_s17, Reg_s18, Reg_s19, Reg_d8 , Reg_d9 , Reg_q4))    \
  X(Reg_q3 , 3 , "q3", 1, 0, 0, 0, 0, 0, 0, 1,                                 \
    ALIASES7(Reg_s12, Reg_s13, Reg_s14, Reg_s15, Reg_d6 , Reg_d7 , Reg_q3))    \
  X(Reg_q2 , 2 , "q2", 1, 0, 0, 0, 0, 0, 0, 1,                                 \
    ALIASES7(Reg_s8 , Reg_s9 , Reg_s10, Reg_s11, Reg_d4 , Reg_d5 , Reg_q2))    \
  X(Reg_q1 , 1 , "q1", 1, 0, 0, 0, 0, 0, 0, 1,                                 \
    ALIASES7(Reg_s4 , Reg_s5 , Reg_s6 , Reg_s7 , Reg_d2 , Reg_d3 , Reg_q1))    \
  X(Reg_q0 , 0 , "q0", 1, 0, 0, 0, 0, 0, 0, 1,                                 \
    ALIASES7(Reg_s0 , Reg_s1 , Reg_s2 , Reg_s3 , Reg_d0 , Reg_d1 , Reg_q0)) 
//#define X(val, encode, name, scratch, preserved, stackptr, frameptr,
//          isInt, isFP32, isFP64, isVec128, alias_init)
#undef ALIASES

// We also provide a combined table, so that there is a namespace where
// all of the registers are considered and have distinct numberings.
// This is in contrast to the above, where the "encode" is based on how
// the register numbers will be encoded in binaries and values can overlap.
#define REGARM32_TABLE                                                         \
  /* val, encode, name, scratch, preserved, stackptr, frameptr, isInt,         \
     isFP32, isFP64, isVec128, alias_init */                                   \
  REGARM32_GPR_TABLE                                                           \
  REGARM32_FP32_TABLE                                                          \
  REGARM32_FP64_TABLE                                                          \
  REGARM32_VEC128_TABLE
//#define X(val, encode, name, scratch, preserved, stackptr, frameptr,
//          isInt, isFP32, isFP64, isVec128, alias_init)

#define REGARM32_TABLE_BOUNDS                                                  \
  /* val, init */                                                              \
  X(Reg_GPR_First, = Reg_r0)                                                   \
  X(Reg_GPR_Last, = Reg_pc)                                                    \
  X(Reg_SREG_First, = Reg_s0)                                                  \
  X(Reg_SREG_Last, = Reg_s31)                                                  \
  X(Reg_DREG_First, = Reg_d0)                                                  \
  X(Reg_DREG_Last, = Reg_d31)                                                  \
  X(Reg_QREG_First, = Reg_q0)                                                  \
  X(Reg_QREG_Last, = Reg_q15)
// define X(val, init)

// Load/Store instruction width suffixes and FP/Vector element size suffixes
// the # of offset bits allowed as part of an addressing mode (for sign or
// zero extending load/stores).
#define ICETYPEARM32_TABLE                                                     \
  /* tag,          element type, int_width, vec_width, addr bits sext, zext */ \
  X(IceType_void,  IceType_void, "" , ""    , 0 , 0)                           \
  X(IceType_i1,    IceType_void, "b", ""    , 8 , 12)                          \
  X(IceType_i8,    IceType_void, "b", ""    , 8 , 12)                          \
  X(IceType_i16,   IceType_void, "h", ""    , 8 , 8)                           \
  X(IceType_i32,   IceType_void, "" , ""    , 12, 12)                          \
  X(IceType_i64,   IceType_void, "d", ""    , 8 , 8)                           \
  X(IceType_f32,   IceType_void, "" , ".f32", 10, 10)                          \
  X(IceType_f64,   IceType_void, "" , ".f64", 10, 10)                          \
  X(IceType_v4i1,  IceType_i32 , "" , ".i32", 0 , 0)                           \
  X(IceType_v8i1,  IceType_i16 , "" , ".i16", 0 , 0)                           \
  X(IceType_v16i1, IceType_i8  , "" , ".i8" , 0 , 0)                           \
  X(IceType_v16i8, IceType_i8  , "" , ".i8" , 0 , 0)                           \
  X(IceType_v8i16, IceType_i16 , "" , ".i16", 0 , 0)                           \
  X(IceType_v4i32, IceType_i32 , "" , ".i32", 0 , 0)                           \
  X(IceType_v4f32, IceType_f32 , "" , ".f32", 0 , 0)
//#define X(tag, elementty, int_width, vec_width, sbits, ubits)

// Shifter types for Data-processing operands as defined in section A5.1.2.
#define ICEINSTARM32SHIFT_TABLE                                                \
  /* enum value, emit */                                                       \
  X(LSL, "lsl")                                                                \
  X(LSR, "lsr")                                                                \
  X(ASR, "asr")                                                                \
  X(ROR, "ror")                                                                \
  X(RRX, "rrx")
//#define X(tag, emit)

// Attributes for the condition code 4-bit encoding (that is independent
// of the APSR's NZCV fields). For example, EQ is 0, but corresponds to
// Z = 1, and NE is 1, but corresponds to Z = 0.
#define ICEINSTARM32COND_TABLE                                                 \
  /* enum value, encoding, opposite, emit */                                   \
  X(EQ, 0 , NE, "eq")   /* equal */                                            \
  X(NE, 1 , EQ, "ne")   /* not equal */                                        \
  X(CS, 2 , CC, "cs")   /* carry set/unsigned (AKA hs: higher or same) */      \
  X(CC, 3 , CS, "cc")   /* carry clear/unsigned (AKA lo: lower) */             \
  X(MI, 4 , PL, "mi")   /* minus/negative */                                   \
  X(PL, 5 , MI, "pl")   /* plus/positive or zero */                            \
  X(VS, 6 , VC, "vs")   /* overflow (float unordered) */                       \
  X(VC, 7 , VS, "vc")   /* no overflow (float not unordered) */                \
  X(HI, 8 , LS, "hi")   /* unsigned higher */                                  \
  X(LS, 9 , HI, "ls")   /* unsigned lower or same */                           \
  X(GE, 10, LT, "ge")  /* signed greater than or equal */                      \
  X(LT, 11, GE, "lt")  /* signed less than */                                  \
  X(GT, 12, LE, "gt")  /* signed greater than */                               \
  X(LE, 13, GT, "le")  /* signed less than or equal */                         \
  X(AL, 14, kNone, "") /* always (unconditional) */                            \
  X(kNone, 15, kNone, "??") /* special condition / none */
//#define(tag, encode, opp, emit)

#endif // SUBZERO_SRC_ICEINSTARM32_DEF
