//===- subzero/src/IceInstARM32.def - X-Macros for ARM32 insts --*- C++ -*-===//
//
//                        The Subzero Code Generator
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines properties of ARM32 instructions in the form of x-macros.
//
//===----------------------------------------------------------------------===//

#ifndef SUBZERO_SRC_ICEINSTARM32_DEF
#define SUBZERO_SRC_ICEINSTARM32_DEF

// NOTE: PC and SP are not considered isInt, to avoid register allocating.
//
// For the NaCl sandbox we also need to r9 for TLS, so just reserve always.
// TODO(jvoung): Allow r9 to be isInt when sandboxing is turned off
// (native mode).
//
// LR is not considered isInt to avoid being allocated as a register.
// It is technically preserved, but save/restore is handled separately,
// based on whether or not the function MaybeLeafFunc.
#define REGARM32_GPR_TABLE                                                     \
  /* val, encode, name, scratch, preserved, stackptr, frameptr, isInt, isFP */ \
  X(Reg_r0,  = 0,            "r0",  1, 0, 0, 0, 1, 0)                   \
  X(Reg_r1,  = Reg_r0 + 1,   "r1",  1, 0, 0, 0, 1, 0)                   \
  X(Reg_r2,  = Reg_r0 + 2,   "r2",  1, 0, 0, 0, 1, 0)                   \
  X(Reg_r3,  = Reg_r0 + 3,   "r3",  1, 0, 0, 0, 1, 0)                   \
  X(Reg_r4,  = Reg_r0 + 4,   "r4",  0, 1, 0, 0, 1, 0)                   \
  X(Reg_r5,  = Reg_r0 + 5,   "r5",  0, 1, 0, 0, 1, 0)                   \
  X(Reg_r6,  = Reg_r0 + 6,   "r6",  0, 1, 0, 0, 1, 0)                   \
  X(Reg_r7,  = Reg_r0 + 7,   "r7",  0, 1, 0, 0, 1, 0)                   \
  X(Reg_r8,  = Reg_r0 + 8,   "r8",  0, 1, 0, 0, 1, 0)                   \
  X(Reg_r9,  = Reg_r0 + 9,   "r9",  0, 1, 0, 0, 0, 0)                   \
  X(Reg_r10, = Reg_r0 + 10,  "r10", 0, 1, 0, 0, 1, 0)                   \
  X(Reg_fp,  = Reg_r0 + 11,  "fp",  0, 1, 0, 1, 1, 0)                   \
  X(Reg_ip,  = Reg_r0 + 12,  "ip",  1, 0, 0, 0, 1, 0)                   \
  X(Reg_sp,  = Reg_r0 + 13,  "sp",  0, 0, 1, 0, 0, 0)                   \
  X(Reg_lr,  = Reg_r0 + 14,  "lr",  0, 0, 0, 0, 0, 0)                   \
  X(Reg_pc,  = Reg_r0 + 15,  "pc",  0, 0, 0, 0, 0, 0)                   \
//#define X(val, encode, name, scratch, preserved, stackptr, frameptr,
//          isInt, isFP)

// TODO(jvoung): List FP registers and know S0 == D0 == Q0, etc.
// Be able to grab even registers, and the corresponding odd register
// for each even register.

// We also provide a combined table, so that there is a namespace where
// all of the registers are considered and have distinct numberings.
// This is in contrast to the above, where the "encode" is based on how
// the register numbers will be encoded in binaries and values can overlap.
#define REGARM32_TABLE                                                  \
  /* val, encode, name, scratch, preserved, stackptr, frameptr, isInt, isFP */ \
  REGARM32_GPR_TABLE
//#define X(val, encode, name, scratch, preserved, stackptr, frameptr,
//          isInt, isFP)

#define REGARM32_TABLE_BOUNDS                                           \
  /* val, init */                                                       \
  X(Reg_GPR_First, = Reg_r0)                                            \
  X(Reg_GPR_Last,  = Reg_pc)
//define X(val, init)

// TODO(jvoung): add condition code tables, etc.

// Load/Store instruction width suffixes.
#define ICETYPEARM32_TABLE                                              \
  /* tag,          element type, width, addr off bits sext, zext */     \
  X(IceType_void,  IceType_void, "",  0, 0)                             \
  X(IceType_i1,    IceType_void, "b", 8, 12)                            \
  X(IceType_i8,    IceType_void, "b", 8, 12)                            \
  X(IceType_i16,   IceType_void, "h", 8, 8)                             \
  X(IceType_i32,   IceType_void, "", 12, 12)                            \
  X(IceType_i64,   IceType_void, "d", 8, 8)                             \
  X(IceType_f32,   IceType_void, "", 10, 10)                            \
  X(IceType_f64,   IceType_void, "", 10, 10)                            \
  X(IceType_v4i1,  IceType_i32 , "",  0,  0)                            \
  X(IceType_v8i1,  IceType_i16 , "",  0,  0)                            \
  X(IceType_v16i1, IceType_i8  , "",  0,  0)                            \
  X(IceType_v16i8, IceType_i8  , "",  0,  0)                            \
  X(IceType_v8i16, IceType_i16 , "",  0,  0)                            \
  X(IceType_v4i32, IceType_i32 , "",  0,  0)                            \
  X(IceType_v4f32, IceType_f32 , "",  0,  0)                            \
//#define X(tag, elementty, width, sbits, ubits)

// Shifter types for Data-processing operands as defined in section A5.1.2.
#define ICEINSTARM32SHIFT_TABLE                                         \
  /* enum value, emit */                                                \
  X(LSL, "lsl")                                                         \
  X(LSR, "lsr")                                                         \
  X(ASR, "asr")                                                         \
  X(ROR, "ror")                                                         \
  X(RRX, "rrx")                                                         \
//#define X(tag, emit)

// Attributes for the condition code 4-bit encoding (that is independent
// of the APSR's NZCV fields). For example, EQ is 0, but corresponds to
// Z = 1, and NE is 1, but corresponds to Z = 0.
#define ICEINSTARM32COND_TABLE                                          \
  /* enum value, encoding, opposite, emit */                            \
  X(EQ, 0, NE, "eq") /* equal */                                        \
  X(NE, 1, EQ, "ne") /* not equal */                                    \
  X(CS, 2, CC, "cs") /* carry set/unsigned (AKA hs: higher or same) */  \
  X(CC, 3, CS, "cc") /* carry clear/unsigned (AKA lo: lower) */         \
  X(MI, 4, PL, "mi") /* minus/negative */                               \
  X(PL, 5, MI, "pl") /* plus/positive or zero */                        \
  X(VS, 6, VC, "vs") /* overflow (float unordered) */                   \
  X(VC, 7, VS, "vc") /* no overflow (float not unordered) */            \
  X(HI, 8, LS, "hi") /* unsigned higher */                              \
  X(LS, 9, HI, "ls") /* unsigned lower or same */                       \
  X(GE, 10, LT, "ge") /* signed greater than or equal */                \
  X(LT, 11, GE, "lt") /* signed less than */                            \
  X(GT, 12, LE, "gt") /* signed greater than */                         \
  X(LE, 13, GT, "le") /* signed less than or equal */                   \
  X(AL, 14, kNone, "") /* always (unconditional) */                     \
  X(kNone, 15, kNone, "??") /* special condition / none */              \
//#define(tag, encode, opp, emit)

#endif // SUBZERO_SRC_ICEINSTARM32_DEF
