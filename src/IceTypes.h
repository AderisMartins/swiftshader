//===- subzero/src/IceTypes.h - Primitive ICE types -------------*- C++ -*-===//
//
//                        The Subzero Code Generator
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file declares a few properties of the primitive types allowed
// in Subzero.  Every Subzero source file is expected to include
// IceTypes.h.
//
//===----------------------------------------------------------------------===//

#ifndef SUBZERO_SRC_ICETYPES_H
#define SUBZERO_SRC_ICETYPES_H

#include "IceTypes.def"

namespace Ice {

enum Type {
#define X(tag, size, align, elts, elty, str) tag,
  ICETYPE_TABLE
#undef X
      IceType_NUM
};

enum TargetArch {
  Target_X8632,
  Target_X8664,
  Target_ARM32,
  Target_ARM64
};

enum OptLevel {
  Opt_m1,
  Opt_0,
  Opt_1,
  Opt_2
};

size_t typeWidthInBytes(Type Ty);
size_t typeAlignInBytes(Type Ty);
size_t typeNumElements(Type Ty);
Type typeElementType(Type Ty);
const char *typeString(Type Ty);

bool isVectorType(Type Ty);

bool isIntegerType(Type Ty); // scalar or vector
bool isScalarIntegerType(Type Ty);
bool isVectorIntegerType(Type Ty);
bool isIntegerArithmeticType(Type Ty);

bool isFloatingType(Type Ty); // scalar or vector
bool isScalarFloatingType(Type Ty);
bool isVectorFloatingType(Type Ty);

/// Returns true if the given type can be used in a load instruction.
bool isLoadStoreType(Type Ty);

/// Returns type generated by applying the compare instructions (icmp and fcmp)
/// to arguments of the given type. Returns IceType_void if compare is not
/// allowed.
Type getCompareResultType(Type Ty);

/// Returns the number of bits in a scalar integer type.
SizeT getScalarIntBitWidth(Type Ty);

// Check if a type is byte sized (slight optimization over typeWidthInBytes).
inline bool isByteSizedType(Type Ty) {
  bool result = Ty == IceType_i8 || Ty == IceType_i1;
  assert(result == (1 == typeWidthInBytes(Ty)));
  return result;
}

// Check if Ty is byte sized and specifically i8. Assert that it's not
// byte sized due to being an i1.
inline bool isByteSizedArithType(Type Ty) {
  assert(Ty != IceType_i1);
  return Ty == IceType_i8;
}

// Return true if Ty is i32. This asserts that Ty is either i32 or i64.
inline bool isInt32Asserting32Or64(Type Ty) {
  bool result = Ty == IceType_i32;
  assert(result || Ty == IceType_i64);
  return result;
}

// Return true if Ty is f32. This asserts that Ty is either f32 or f64.
inline bool isFloat32Asserting32Or64(Type Ty) {
  bool result = Ty == IceType_f32;
  assert(result || Ty == IceType_f64);
  return result;
}

template <typename StreamType>
inline StreamType &operator<<(StreamType &Str, const Type &Ty) {
  Str << typeString(Ty);
  return Str;
}

} // end of namespace Ice

#endif // SUBZERO_SRC_ICETYPES_H
